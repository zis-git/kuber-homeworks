# Домашнее задание к занятию «Хранение в K8s» Голоха Е.В. 

## Цель работы
- Обмен файлами между контейнерами внутри пода (Volume / emptyDir).
- Работа с **PersistentVolume (PV)** и **PersistentVolumeClaim (PVC)** на локальной ноде.
- Создание **StorageClass (SC)** и подключение хранилища через PVC.

---

## Содержание
- [Используемый стенд](#используемый-стенд)
- [Задание 1. Volume: обмен данными между контейнерами в поде](#задание-1-volume-обмен-данными-между-контейнерами-в-поде)
- [Задание 2. PV, PVC](#задание-2-pv-pvc)
- [Задание 3. StorageClass](#задание-3-storageclass)
- [Использованные манифесты](#использованные-манифесты)
- [Скриншоты](#скриншоты)
- [Итог](#итог)

---

## Используемый стенд
- ОС: `Debian GNU/Linux 13 (trixie)`
- Kubernetes: `MicroK8s v1.33.7`
- Управление кластером: `/snap/bin/microk8s kubectl`

Проверка ноды:
```bash
/snap/bin/microk8s kubectl get nodes -o wide
``` 
<img width="1034" height="73" alt="2026-02-11_18-22-08" src="https://github.com/user-attachments/assets/9395187f-d3fb-4328-be89-0fd12f85b8e8" />

![Проверка ноды](./img/2026-02-11_18-22-08.png)

---

## Задание 1. Volume: обмен данными между контейнерами в поде

### Что сделано
1. Создан `Deployment` **data-exchange** с двумя контейнерами:
   - `busybox:1.36`
   - `wbitt/network-multitool:latest`
2. Добавлен общий том **emptyDir**, примонтированный:
   - в `busybox` как `/shared`
   - в `multitool` как `/shared`
3. `busybox` пишет в файл `/shared/data.txt` каждые 5 секунд.
4. `multitool` читает файл командой `tail -f /shared/data.txt`.

### Применение
```bash
/snap/bin/microk8s kubectl apply -f manifests/containers-data-exchange.yaml
```

### Проверка (по требованиям задания)
Ожидание готовности пода:
```bash
/snap/bin/microk8s kubectl get pods -l app=data-exchange -w
```
 
<img width="788" height="108" alt="2026-02-11_19-07-54" src="https://github.com/user-attachments/assets/543e1218-506d-4f94-9db2-8d5fd144bd37" />

![Pod Running](./img/2026-02-11_19-07-54.png)

Описание пода с контейнерами:
```bash
/snap/bin/microk8s kubectl describe pod <pod_name>
```
<img width="1164" height="939" alt="2026-02-11_19-10-15" src="https://github.com/user-attachments/assets/a96ce96a-d7d3-4145-9ada-772c674ca1f1" />

![kubectl describe pod](./img/2026-02-11_19-10-15.png)

Вывод чтения файла (`tail -f`):
> так как контейнер `multitool` запускается с `tail -f /shared/data.txt`, его вывод удобно смотреть через `kubectl logs`.
```bash
/snap/bin/microk8s kubectl logs <pod_name> -c multitool --tail=30
```
<img width="933" height="88" alt="2026-02-11_19-11-44" src="https://github.com/user-attachments/assets/7d58660f-bbe0-4252-bc5d-f88bae370050" />

![tail -f общего файла](./img/2026-02-11_19-11-44.png)

---

## Задание 2. PV, PVC

### Что сделано
1. Создан локальный `PersistentVolume` **pv-local** (hostPath: `/data/pv-local`) с политикой **Retain**.
2. Создан `PersistentVolumeClaim` **pvc-local** и `Deployment` **data-exchange-pvc**, который использует PVC.
3. Показано, что данные пишутся `busybox` и читаются `multitool` из одного и того же файла в смонтированной директории.
4. Удалены `Deployment` и `PVC` — проверено состояние `PV` и объяснено, почему так происходит.
5. Проверено наличие файла на ноде, затем удалён `PV` и проверено, что стало с файлом.

### Применение (создание PV+PVC+Deployment)
```bash
/snap/bin/microk8s kubectl apply -f manifests/pv-pvc.yaml
```
 
<img width="706" height="108" alt="2026-02-11_19-13-25" src="https://github.com/user-attachments/assets/ee8ec460-2081-40af-b036-9da5f6468849" />

![apply pv-pvc.yaml](./img/2026-02-11_19-13-25.png)

### Шаг 2 — PV и PVC
Проверка статуса PV/PVC:
```bash
/snap/bin/microk8s kubectl get pv,pvc -o wide
```

На первом запуске встретилась проблема привязки PVC к PV (mismatch StorageClass) — PVC остался в `Pending`.

<img width="1124" height="150" alt="2026-02-11_19-13-48" src="https://github.com/user-attachments/assets/26b2ecf5-5cd8-4ad8-982d-120e5c954b1c" />

![Pending из-за StorageClass mismatch](./img/2026-02-11_19-13-48.png)

После исправления `storageClassName` (PV и PVC приведены к одному значению **local-manual**) PV и PVC перешли в `Bound`.
  
<img width="1228" height="123" alt="2026-02-11_19-19-08" src="https://github.com/user-attachments/assets/e7160af4-d2f4-4335-a11f-8cf9e7c74a99" />

![PV/PVC Bound](./img/2026-02-11_19-19-08.png)

### Шаг 3 — демонстрация чтения файла (файл обновляется каждые 5 секунд)
Команда чтения из `multitool`:
```bash
/snap/bin/microk8s kubectl exec -it <pod_name> -c multitool -- sh -c 'tail -n 5 /shared/data.txt'
sleep 6
/snap/bin/microk8s kubectl exec -it <pod_name> -c multitool -- sh -c 'tail -n 5 /shared/data.txt'
```

<img width="1389" height="239" alt="2026-02-11_19-21-50" src="https://github.com/user-attachments/assets/4aed2c43-eac1-4294-b746-07b5338a919d" />

![Данные обновляются](./img/2026-02-11_19-21-50.png)

### Шаг 4 — удаление Deployment и PVC, проверка PV
Удаление `Deployment` и `PVC`:
```bash
/snap/bin/microk8s kubectl delete deployment data-exchange-pvc
/snap/bin/microk8s kubectl delete pvc pvc-local
```

После удаления `PVC` `PV` перешёл в состояние `Released`.
 
<img width="1113" height="98" alt="2026-02-11_19-23-39" src="https://github.com/user-attachments/assets/c99eaba4-0656-4c1d-8e8f-18d70197409f" />

![PV Released](./img/2026-02-11_19-23-39.png)

Описание PV:
```bash
/snap/bin/microk8s kubectl describe pv pv-local
```

<img width="1011" height="339" alt="2026-02-11_19-24-47" src="https://github.com/user-attachments/assets/e0ce4201-48ee-4821-81c0-48d8cbc8be18" />

![kubectl describe pv](./img/2026-02-11_19-24-47.png)

**Пояснение:** у PV установлена политика `persistentVolumeReclaimPolicy: Retain`, поэтому при удалении PVC Kubernetes **не удаляет данные** и не чистит каталог на ноде. PV остаётся `Released` (привязка к старому claim сохраняется в `claimRef`), и такой PV нельзя автоматически переиспользовать без ручной очистки/пересоздания.

### Шаг 5 — проверка файла на ноде и удаление PV
Проверка наличия файла на локальном диске ноды:
```bash
ls -la /data/pv-local && tail -n 5 /data/pv-local/data.txt
```

<img width="754" height="108" alt="2026-02-11_19-25-27" src="https://github.com/user-attachments/assets/84b84b04-ed91-431c-9bf1-152c51bcd885" />

![Файл сохранился на ноде](./img/2026-02-11_19-25-27.png)

Удаление PV:
```bash
/snap/bin/microk8s kubectl delete pv pv-local
```
Проверка каталога/файла после удаления PV:
```bash
ls -la /data/pv-local && tail -n 3 /data/pv-local/data.txt
```
 
<img width="745" height="123" alt="2026-02-11_19-27-00" src="https://github.com/user-attachments/assets/26e77cc6-e1f0-4172-b52a-3f5b176e9d60" />

![После удаления PV файл остался](./img/2026-02-11_19-27-00.png)

**Пояснение:** PV типа `hostPath` указывает на директорию на диске ноды. Удаление объекта PV из Kubernetes **не удаляет** директорию/файл на хосте — это делается вручную (по требованиям и политике эксплуатации).

---

## Задание 3. StorageClass

### Что сделано
1. Создан `StorageClass` **local-sc** (`kubernetes.io/no-provisioner`, `WaitForFirstConsumer`).
2. Созданы `PV` **pv-local-sc**, `PVC` **pvc-local-sc** и `Deployment` **data-exchange-sc**, который использует PVC.
3. Показано, что `multitool` читает файл, который `busybox` обновляет каждые 5 секунд (в примере файл `/data/data.txt`).

### Применение
```bash
/snap/bin/microk8s kubectl apply -f manifests/sc.yaml
```

### Шаг 2 — проверка SC/PV/PVC
```bash
/snap/bin/microk8s kubectl get sc,pv,pvc -o wide
```

<img width="1296" height="185" alt="2026-02-11_19-28-07" src="https://github.com/user-attachments/assets/07deffd4-14de-4331-8a7b-408060b13092" />

![SC/PV/PVC](./img/2026-02-11_19-28-07.png)

### Шаг 3 — чтение файла из multitool
```bash
/snap/bin/microk8s kubectl exec -it <pod_name> -c multitool -- sh -c 'tail -n 10 /data/data.txt'
```
  
<img width="1148" height="74" alt="2026-02-11_19-31-44" src="https://github.com/user-attachments/assets/4766f36f-17ee-4f1d-8fc7-4bfc1600fcf1" />

![Чтение файла в SC варианте](./img/2026-02-11_19-31-44.png)

---

## Использованные манифесты
- `manifests/containers-data-exchange.yaml` — Задание 1 (emptyDir + busybox/multitool)
- `manifests/pv-pvc.yaml` — Задание 2 (PV + PVC + Deployment с PVC)
- `manifests/sc.yaml` — Задание 3 (StorageClass + PV/PVC + Deployment)

---

---

## Итог
- **Задание 1:** реализован обмен данными между контейнерами внутри пода через `emptyDir`.
- **Задание 2:** создан PV/PVC вручную, показано сохранение данных при `Retain`, объяснены статусы PV после удаления PVC и после удаления PV (hostPath данные остаются на ноде).
- **Задание 3:** создан `StorageClass` и выполнено подключение PVC на его основе, данные доступны в поде и обновляются.
